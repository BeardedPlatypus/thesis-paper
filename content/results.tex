\section{Results and Discussion}

In order for Hashed Shading to be viable, it would need to perform similarly to
Tiled and Clustered Shading. Furthermore it should not use an excessive amount
of memory. 


\subsection{Construction Time and Memory Usage}

The results of the construction time for different number of lights as function of the
node size can be found in figure \ref{}. The construction time of the individual steps
are shown in figure \ref{}. We can clearly see a cubic relation between the node size
and the execution time. This leads to a significant increase when more than $8^3$ nodes per
light are used. This is primarily due to the construction time of the spatial hash functions
which represent the layers.

The same cubic relationship can be seen in the memory usage. Both the size of the light index
list and the combined number of pixels within the textures used by the linkless octree show
cubic growth with regards to a smaller node size. The majority of the memory is used in
the deepest layers of the linkless octree. The size of the light index list is an indication
for the number of non-empty leaf nodes. A smaller node size allows for a more fine grained
representation of space, thus, partly overlapping lights will produce more deep octree nodes.
The overlap within lights will create a difference in the light set contained in the nodes,
and thus spawn a larger number of small octree nodes.

The node size affects the size in all three dimensions of the node, thus if the node size
is halved it will span $\frac{1}{2}^3 = 8$ times as many nodes. This cubic increase in
nodes drives both the memory usage, and the construction time.

\subsection{Execution Time and Light Calculations}

Figure \ref{} shows the execution time for both the forward and deferred pipelines during
a single evaluation of both hashed shading and tiled shading. Figure \ref{} shows the
number of light calculations during a single simulation of the deferred pipeline for
tiled, clustered and hashed shading.

In the Deferred Pipeline we can see a similar performance for Tiled and Hashed Shading.
However Hashed Shading requires a factor two less light calculations. Due to the simple
fragment shader used, this difference in number of light calculations is not significant
enough to create a difference in execution time. If a more complex shader would be used,
the difference in number of light calculations should be noticeable. The Forward Shading
pipeline has a significant amount of overdraw, thus a larger number of fragments per
pixel is evaluated. In this situation Hashed Shading performs about two times faster,
in line with the results from the reduction in number of light calculations.

For small node sizes the Hashed Shading algorithm approaches the reduction in light calculations
of Clustered Shading. While Clustered Shading still requires less light calculations, the
difference in minimal. A further reduction in node size should reduce the gap in light calculations.

In figure \ref{} the average execution time per frame for the Forward and Deferred pipelines as
function of the number of lights is plotted. All of the algorithms scale linearly with the
number of lights. The results are comparable to those of the single simulation. For Deferred
Shading the performance increase of Hashed Shading is similar to that of Tiled Shading. In
the Forward pipeline, again an improvement of a factor is noticeable.
The number of light calculations, figure \ref{}, shows that the reduction in calculation time
is again a direct result of the reduction of number of light calculations. The smallest node
size shows a comparable curve to that of Clustered Shading.

The behaviour with regards to the resolution is shown in figure \ref{} and \ref{}.
Both the execution time and the number of light calculations are linearly dependent on
the number of fragments. 
Hashed Shading performs slightly better with increasing resolutions, though the effect
is almost negligible. The memory usage of both Tiled and Clustered Shading is directly
linked to the size of view port. Hashed Shading has no such dependency, thus it will not
be significantly affected by changing resolutions. With the trend of growing resolutions,
this might prove to be an important attribute of Hashed Shading.

