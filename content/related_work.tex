\section{Related Work}

\subsection{Deferred Shading}

A first step into reducing the number of light calculations is decoupling
geometry and shading complexity. In the modern graphical pipeline all geometry
in the view frustum generates samples to be shaded, regardless of whether these
are visible or occluded. These samples are all shaded and only after executing
the light calculations the visibility of pixels is determined in the per-pixel
operations. In order to shade only the visible samples, the visibility has to be
determined before shading. The concept to achieve this was introduced in hardware
design in 1988\cite{deering1988triangle}. A general purpose strategy to achieve
this deferred shading was introduced in 1990, making use of so called
geometry buffers or GBuffers\cite{saito1990comprehensible}. The idea
is to execute the render pipeline twice per frame. In the first pass all
attributes necessary to perform the shading computation are rendered into screen
size textures, the GBuffers. In the second pass one sample per pixel is generated and
for these samples the values are retrieved from the GBuffer and used to shade
the pixel. This way the visibility is determined for the attributes in the in
the per-pixel operations of the first pass. Then only the attributes of the
visible samples are retrieved in the second pass.

A first light assignment approach is to rasterise the light volumes during the
second pass. The shading contributions per light are then only calculated for
the samples generated by its light volume. This reduces the total number
of light calculations, as not every light will be evaluated for every pixel.
This optimisation is called the stencil-optimisation\cite{doi:10.1080/10867651.2003.10487587}.
This approach has two downsides. It requires a significant number of memory
accesses, as per generated sample the shading data has to be retrieved from the
GBuffers. Also, the summation of shading contributions happens in a framebuffer.
This reduces the precision as the framebuffer's precision generally does not
have as much bits as the GPU registers.

% A first step into reducing the number of light calculations is decoupling
% geometry and shading complexity. In the modern graphical pipeline, all geometry
% in the view-frustum generates samples, regardless of whether it is occluded.
% These samples are shaded and only after shading the visible samples are
% determined in the per-pixel operations. In order to just shade the visible
% samples, the visibility of the samples has to be determined before shading.
% This concept was introduced in hardware design in 1988\cite{} and is called
% Deferred Shading. In 1990 a general purpose strategy was introduced based on so
% called GBuffers\cite{}. The idea is to render all attributes needed to shade a
% sample into texture buffers the size of the screen. Then in a second, deferred
% step these values are retrieved from the buffers to calculate the shading
% contribution.

% A first light assignment approach is to rasterise the light volumes, and
% only calculate the contribution of the light for the generated samples.
% This technique is called the stencil-optimalisation\cite{}. This reduces
% the number of light calculations, as no longer for each sample each light
% has to be evaluated, however there are two also two disadvantages of this
% optimalisation. Firstly it requires a significant number of memory
% accesses, as for each generated sample, the GBuffers have to be sampled.
% Secondly the light contributions are accumulated in a buffer, thus leading
% to small rounding errors.

\subsection{Tiled Shading}

Tiled Shading\cite{olsson2011tiled} was designed to alleviate the memory
bandwidth bottleneck of Deferred Shading with the stencil-optimisation. The
underlying idea is to calculate which lights effect which pixels before shading,
instead of during. This is achieved by subdividing the screen space into tiles
of $n \times n$ pixels. For each tile the light indices of the lights which
projected light volumes overlap with the tile, are stored. The tiles can
subsequently be used to retrieve the set of relevant lights during shading.
This can be done by determining the tile in which a pixel falls, and retrieving
the light indices associated with this tile.
Tiles can be constructed by projecting the light volumes on the view port and
determining with which tiles it overlaps. To each of the tiles with which the light
overlaps, the light index of the light is added.

A further optimisation can be done by calculating the minimum and maximum
$z$-values for each tile. These can then be used to reject any light which falls
outside of these boundaries, thus reducing the number of lights associated with
a tile.

This algorithm has been implemented in several game engines and
games\cite{balestra2008technology, swoboda2009deferred, balestra2008technology},
including Unreal\cite{karis2013real},
frostbite\cite{andersson2009parallel, magnusson2011lighting}
and unity\cite{pranckevivcius2014physically}.

% Tiled Shading was designed to alleviate the memory bandwidth bottleneck of
% Deferred Shading with the stencil-optimalisation. The concept is to divide
% the screen space into tiles of $\mathit{n} \times \mathit{n}$ pixels. For
% each tile the light indices of the overlapping light volumes are stored.
% The tiles are subsequently used to determine the set of relevant lights per
% sample by retrieving the set of light indices associated with the tile the
% sample falls within. This technique thus only requires a single memory access
% per sample, instead of a memory access per light, thus reducing the memory
% bandwidth significantly.

% The tiles can be constructed by projecting the light volumes on the view port
% and determining with which tiles it overlaps. The corresponding light index
% is added to each of these tiles. A further optimalisation is to reduce the
% tile volume by only considering lights that fall within the minimum and
% maximum $z$-value of the tile. Any light that does not overlap with this
% sub frustum, is not added to the tile.

% This technique has been implemented in a number of games\cite{} and game engines\cite{}, including
% the unreal engine\cite{}, the frostbyte engine\cite{} and unity\cite{}.

\subsection{Clustered Shading}

Clustered Shading\cite{olsson2012clustered} extends Tiled Shading by subdividing the
volumes associated with the tiles further. The tile volumes are subdivided with regards to the
camera's $z$-axis to obtain cube-like sub frustums. These sub frustums can be further
partitioned based on attributes such as the normals. These higher dimension tiles are
called clusters.

The clusters are constructed by first determining the set of cluster volumes which contain
visible geometry. This is done by transforming the depth buffer into a cluster buffer by
binning the $z$-values. This cluster buffer is sorted and compacted locally per tile to
extract the set of unique clusters. At the same time a mapping is build, such that
for each pixel the corresponding cluster can be looked up.
To each of the unique clusters the indices of overlapping lights are added.

During the shading step for each pixel the set of relevant lights is determined
by first looking up the corresponding cluster associated with a pixel and then
retrieving the set of lights overlapping with this cluster. The shading contributions
of each of these lights are evaluated similarly to Tiled shading.

This subdivision of the view frustum is more fine-grained than that of Tiled Shading, and
thus reduces the number of light calculations per pixel to a greater extend.
Clustered Shading is used in several modern games, including in the Avalance
game engine, on which games as Just Cause 2 and 3\cite{persson2013practical},
Doom 4\cite{Tatarchuk:2016:ARR:2897826.2940292}.

% Clustered Shading\cite{} extends Tiled Shading by subdividing the space associated
% with each tile further. The tiles are subdivided exponentially in the camera
% $z$-axis to gain cube-like sub frustums. For each of the sub frustums containing
% geometry, the overlapping lights are calculated. Furthermore additional
% attributes like normals can be used to create even more precise light assignment.

% The subdivision is constructed by first determining the set of clusters which
% contain geometry. This is done by transforming the depth buffer in a cluster
% buffer, by assigning each sample to a distinct bin. Then the unique clusters
% are obtained by locally sorting and compacting each tile. The cluster buffer
% is then used to create a mapping from each sample to the unique cluster to
% which it belongs. For each of the unique clusters the overlapping lights
% are added to construct a set of light indices.

% During the shading step the set of light indices is retrieved using the
% sample to cluster mapping constructed during the construction of the data
% structures. For each of these lights the contributions is calculated and
% summed similarly to Tiled Shading.

% Clustered Shading is used in several modern games, including in the Avalance
% game engine, on which games as Just Cause 2 and 3\cite{} and Doom 4\cite{} are build.

\subsection{Perfect Spatial Hashing}

In order to efficiently subdivide the scene space without using a large amount
of memory, an octree data structure is used. A straightforward implementation
using pointers would require a large number of control structures. Such control
structures would degrade the performance of the data structure on the GPU\cite{Han:2011:RBD:1964179.1964184}.
A pointer based data structure would therefore be infeasible for a light assignment
algorithm. In Hashed Shading a Linkless Octree\cite{choi2009linkless} is used. This data structure
builds upon perfect spatial hash functions\cite{lefebvre2006perfect}.

A hash function $\mathit{h}$ can be used to map sparse data $D$ on a compact memory table $H$:

\begin{equation*}
  D\left(\mathbf{p}\right) = H\left[\mathit{h}\left(\mathbf{p}\right)\right]
\end{equation*}

\noindent When the hash function $\mathit{h}$ maps none of the keys $\mathbf{p}$ onto
the same address it is collision-free and called perfect. Perfect hash functions
are ideal for GPU applications. They allow sparse data to be represented efficiently in
memory and each of the elements can be retrieved from memory without needing any control
structures.

Perfect spatial hashing\cite{lefebvre2006perfect} introduces a technique
to construct memory efficient perfect hash functions for higher dimensions which are
spatially coherent. This is done by using two simple imperfect hash functions $\mathit{h}_0$
and $\mathit{h}_1$, and one offset hash table $\Phi$. The perfect hash function $\mathit{h}$
can then be defined as

\begin{equation*}
  \mathit{h}\left(\mathbf{p}\right) = \mathit{h}_0\left(\mathbf{p}\right) + \Phi\left[\mathit{h}_1\left(\mathbf{p}\right)\right]
\end{equation*}

\noindent where $\mathit{h}_0$ and $\mathit{h}_1$ are simple hash functions defined as

\begin{align*}
  \mathit{h}_0:& \mathbf{p} \mapsto \mathbf{p} \operatorname{mod} \dot{m} \\
  \mathit{h}_1:& \mathbf{p} \mapsto \mathbf{p} \operatorname{mod} \dot{r}
\end{align*}

\noindent where $\dot{m}$ is the size of a single dimension of the hash table $H$ and
$\dot{r}$ is the size of a single dimension of the offset hash table $\Phi$.

The underlying idea is that colliding keys in $\mathit{h}_0$ do not collide in
$\mathit{h}_1$, thus by adding an offset defined in $\Phi$ to the calculated
address of $\mathit{h}_0$ the collisions within $\mathit{h}$ are dissolved.

This representation makes it possible to store sparse three dimensional data
compactly in memory. The linkless octree data structure will be build upon these
perfect spatial hash functions.

% In order to efficiently subdivide the scene space without using a large amount
% of memory an octree data structure is used. A straightforward implementation
% using pointers would require a large number of control structures. Control structures
% can lead to a significant performance loss on the GPU\cite{}. Thus such using such
% an octree would not be feasible in a light assignment algorithm. A different
% approach is needed. The linkless octree\cite{} data structure used within this paper
% is based upon perfect spatial hash functions\cite{}.

% Hash functions can be used to map sparse data $D$ on to a compact memory table $H$.

% \begin{equation*}
%   D\left(\mathbf{p}\right) = H\left[ \mathit{h}\left(\mathbf{p} \right) \right]
% \end{equation*}

% \noindent When a hash function is perfect no keys map to the same address. 
% This feature can be used on the GPU as it will ensure no control structures are needed to extract a
% value associated with a key from memory.

% The goal of perfect spatial hashing to hash multi-dimensional sparse data onto a compact
% memory table, without having any collisions and maintaining spatial coherence.
% This makes the data structure fitted for applications on the graphics card.
% The perfect spatial hash function $\mathit{h}$ is build with two imperfect hash functions,
% $\mathit{h}_0$ and $\mathit{h}_1$ and an offset hash table $\Phi$. The idea is to dissolve
% collisions in $\mathit{h}_0$ with the offset values in $\Phi$. This leads to the following
% definition:

% \begin{equation*}
%   \mathit{h}\left(\mathbf{p}\right) = \mathit{h}_0\left(\mathbf{p}\right) + \Phi\left[\mathit{h}_1\left(\mathbf{p}\right)\right]
% \end{equation*}

% \noindent where $\mathit{h}_0$ and $\mathit{h}_1$ are simple hash functions defined as:

% \begin{align*}
%   \mathit{h}_0\left(\mathbf{p}\right) =& \mathbf{p} \operatorname{mod} \dot{m} \\
%   \mathit{h}_1\left(\mathbf{p}\right) =& \mathbf{p} \operatorname{mod} \dot{r}
% \end{align*}

% \noindent where $\dot{m}$ is the dimension of hash table $H$ and $\dot{r}$ the dimension
% of hash table $\Phi$.

% This representation makes it possible to represent sparse three dimensional data efficiently
% in memory. The linkless octree data structure will be build with these perfect spatial hash
% functions.

\subsection{Linkless Octree}

The linkless octree\cite{choi2009linkless} is a GPU efficient octree implementation. Each layer
of the linkless octree implementation is represented by a perfect spatial hash function,
therefore removing the need for pointers between nodes.

An octree contains a number of layers, each containing nodes of a similar size. Because each node
in a single layer has the same size, the position of a node can be represented by a three
dimensional integer vector. Due to the structure of the octree, the nodes of each layer
are generally sparsely distributed over the complete scene space. Each layer can thus be
compactly represented by a perfect spatial hash function, where the keys are the integer
positions of the nodes, and the data is a description of the node at that position.
This description needs to encode whether an octree node is a branch or leaf node, and
whether it contains data or not. Therefore each node can be described by two bits.
Due to memory considerations eight sibling nodes in a layer $l + 1$ are represented
directly by the branch node in layer $l$. This branch node has two 8-bit integers, which
describe each of the child nodes of this branch node directly.

The data associated with the octree nodes needs to be stored as well. There are two
options for doing so. The straightforward solution is to reserve the space necessary
for each data element associated with a node directly in the hash table associated with
a layer. This is a valid approach when the data is small or when the majority of the nodes
contains data. However, when the data is large, or only a small subset of the nodes
actually contains data, this solution would lead to unacceptable memory requirements.
This can be remedied by constructing a second spatial hash function per layer which
will hold the data elements. Each data element associated with a nonempty node in a layer
is stored within this second spatial hash function. Data can then be retrieved from the octree
by first descending into the octree, determining for each layer the type of octree node
encountered. The leaf nodes specifies whether data is associated with a query. If it is, then
this data can be retrieved from the second spatial hash function of the leaf node's layer.


% The linkless octree is a GPU efficient octree implementation, which is utilised in the
% Hashed Shading algorithm. It represents each layer of the octree as a perfect spatial
% hash function.

% An octree contains a number of layers, each layer has a defined node size, thus the position
% of each node can be represented by a three dimensional integer vector. There exists a node
% at position $\mathbf{p}_l$ in layer $\mathit{l}$ if and only if at layer $\mathit{l} - 1$
% there is a branch node containing the node at position $\mathbf{p}_l$ or $\mathbf{p}_l$ is the
% root node of the octree. This means that each layer consists of a set of nodes sparsely distributed
% over the octree space. Each layer can thus be efficiently represented by a perfect spatial hash function.

% In order to encode a layer, the data associated with a node needs to be defined. This data encodes
% the type of an octree node at position $\mathbf{p}$. An octree node can either be a branch
% node or a leaf node, and an octree node can be either empty or non-empty. Thus each octree node
% can be represented by two boolean values. Due to memory considerations eight nodes are combined
% and represented by two 8-bit integers. Since each branch node contains eight children, each
% linkless octree node in layer $\mathit{l}$ represents a branch node containing the types of
% its eight children at depth $\mathit{l}+1$.
% A complete octree can be represented by constructing a perfect spatial hash function for each
% layer.

% The data saved in the octree node needs to be stored as well. There are two options to do this.
% Either the data is stored directly in the hash table of the perfect spatial hash function, or
% the data is stored separately. In case the data is stored directly inside the hash table,
% each hash table entry requires the memory to hold two 8-bit integers and eight times the
% memory of a single data element associated with an octree node. This approach is infeasible
% when the data is large, or only a small subset of nodes actually contains data. In these
% cases the data can be saved in a separate perfect spatial hash function. The hash table
% associated with this second perfect spatial hash function will contain an entry for each non-empty
% child node of the nodes saved in the first spatial hash function.

